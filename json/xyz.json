{
    "transform": "#pragma once\n#include <glm/glm.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <iostream>\n\nclass Transform \n{\npublic:\n\tglm::vec3 position;\n\tglm::quat rotation;\n\tglm::vec3 scale;\n\n\tTransform(glm::vec3 pos = glm::vec3(0.0f),\n\t\tglm::quat rot = glm::quat(1, 0, 0, 0),\n\t\tglm::vec3 scl = glm::vec3(1.0f))\n\t\t: position(pos), rotation(rot), scale(scl) { }\n\n\tvirtual ~Transform() = default;\n\n\tglm::vec3 getRandomPointInRadius(int minDist, int maxDist) const\n\t{\n\t\tfloat angle = std::rand() % 360;\n\t\tfloat distance = minDist + std::rand() % maxDist;\n\n\t\tglm::vec3 point;\n\t\tpoint.x = distance * cos(glm::radians(angle));\n\t\tpoint.y = 0.0f;\n\t\tpoint.z = distance * sin(glm::radians(angle));\n\n\t\treturn point;\n\t}\n\n\tfloat getVectorMagnitude(glm::vec3 vector)\n\t{\n\t\tfloat beforeSqrt = vector.x * vector.x + vector.y * vector.y + vector.z * vector.z;\n\t\treturn glm::sqrt(beforeSqrt);\n\t}\n};",
    "physicsbody": "#include \"Physicsbody.h\"\n#include \"glew/glew.h\"\n#include \"GLFW/glfw3.h\"\n\nvoid Physicsbody::update() \n{\n    double currentFrame = glfwGetTime();\n    deltaTime = currentFrame - lastFrameTime;\n    lastFrameTime = currentFrame;\n    \n    float gravity = -9.81f;\n    float gravityAmplitude = 120.f;\n    if (bGravity) \n    {\n        acceleration.y += gravity * gravityAmplitude * deltaTime;\n    }\n\n    velocity += acceleration * deltaTime;\n\n    double dampingFactor = 1.f - (dampening * deltaTime);\n\n    if (dampingFactor < 0) \n        dampingFactor = 0;\n\n    velocity *= dampingFactor;\n}",
    "physicsbodyh": "#pragma once\n#include \"glm/glm.hpp\"\n\nclass Physicsbody \n{\npublic:\n\tvoid update();\n\n\tvoid add_force(glm::vec3 force)\n\t{\n\t\tacceleration += force;\n\t}\n\n\tglm::vec3 velocity;\n\tglm::vec3 acceleration;\n\n\tbool bGravity = false;\n\n\tfloat dampening = 5.f;\n\tfloat friction = 1.f;\n\n\tfloat deltaTime = 0.f;\n\tfloat lastFrameTime = 0.f;\n};",
    "movement": "#include<iostream>\n\n#include \"Player.h\"\n#include\"Transform.h\"\n#include \"Game.h\"\n#include \"imgui/imgui.h\"\n\nPlayer::Player(Camera* camera)\n    : Entity(), camera(camera), physicsbody()\n{ \n    transform.scale = glm::vec3(0.5f);\n    physicsbody.bGravity = true;\n    collision_channel = Collision_Channel::Player;\n}\n\nvoid Player::update(GLFWwindow* window, float deltaTime) \n{\n    physicsbody.update();\n    shooter.update(deltaTime);\n\n    processKeyboard(window, deltaTime);\n    tiltCamera(window, deltaTime);\n    updateCameraPosition();\n    checkCollision();\n\n    if (!canDash)\n    {\n        dashCooldownTimer -= deltaTime;\n        if (dashCooldownTimer <= 0.0f)\n        {\n            canDash = true;\n            dashCooldownTimer = 0.0f;\n        }\n    }\n}\n\nvoid Player::checkCollision() \n{\n    Entity* hit_actor = game->get_coliding_entity(this, Collision_Channel::Enemy);\n    if (hit_actor != nullptr)\n    {\n        transform.position = glm::vec3(10);\n    }\n\n    Entity* hit_actor2 = game->get_coliding_entity(this, Collision_Channel::XP);\n    if (hit_actor2 != nullptr)\n    {\n        hit_actor2->destroy();\n    }\n}\n\nvoid Player::processKeyboard(GLFWwindow* window, float deltaTime)\n{\n    // movement\n    const float playerSpeed = speed * deltaTime;\n    physicsbody.acceleration = glm::vec3(0.0f);\n\n    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)\n        physicsbody.acceleration += playerSpeed * camera->getCameraForward();\n    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)\n        physicsbody.acceleration -= playerSpeed * camera->getCameraForward();\n    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) \n        physicsbody.acceleration -= glm::normalize(glm::cross(camera->getCameraForward(), camera->getCameraUp())) * playerSpeed;\n    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)\n        physicsbody.acceleration += glm::normalize(glm::cross(camera->getCameraForward(), camera->getCameraUp())) * playerSpeed;\n\n    // jumping and dampening\n\n    bool bIsGrounded = transform.position.y < 0 + playerHeight + 0.1f;\n    physicsbody.dampening = bIsGrounded ? 5.f : 2.f;\n\n    if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS && bIsGrounded)\n    {\n        physicsbody.add_force(glm::vec3(0, 10000 * deltaTime, 0));\n    }\n\n    // dashing\n\n    float vMagnitude = glm::length(physicsbody.velocity);\n\n    if (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS && canDash && vMagnitude > 4)\n    {\n        glm::vec3 dashDirection = glm::normalize(physicsbody.velocity);\n        if (glm::length(dashDirection) > 0.0f)\n        {\n            const float dashSpeed = 40000.0f;\n            physicsbody.add_force(dashDirection * dashSpeed * deltaTime);\n\n            dashCooldownTimer = dashCooldown;\n            canDash = false;\n        }\n    }\n\n    // apply velocity\n    transform.position += physicsbody.velocity * deltaTime;\n    transform.position.y = glm::clamp(transform.position.y, 0.0f + playerHeight, 100.0f);\n}\n\nvoid Player::tiltCamera(GLFWwindow* window, float deltaTime)\n{\n    static float currentTilt = 0.0f;\n    static float lastTilt = 0.0f;\n\n    float rotationSpeed = 10.0f;\n    float maxTilt = 5.0f;\n    float targetTilt = 0.0f;\n\n    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)\n    {\n        targetTilt = -maxTilt;\n    }\n    else if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)\n    {\n        targetTilt = maxTilt;\n    }\n    else\n    {\n        targetTilt = 0.0f;  // no input, return to 0 tilt\n    }\n\n    // lerp current tilt towards the target tilt\n    currentTilt = glm::mix(currentTilt, targetTilt, deltaTime * rotationSpeed);\n\n    // clamp the tilt to the maximum allowed tilt range\n    currentTilt = glm::clamp(currentTilt, -maxTilt, maxTilt);\n\n    // calculate the difference in tilt from the last frame\n    float tiltDifference = currentTilt - lastTilt;\n\n    // apply the tilt relative to the current camera rotation\n    glm::quat tiltQuat = glm::quat(glm::vec3(0.0f, 0.0f, glm::radians(tiltDifference)));\n\n    // combine the tilt rotation with the existing camera rotation correctly\n    camera->transform.rotation = glm::normalize(glm::quat(camera->transform.rotation) * tiltQuat);\n\n    // update last tilt value for the next frame\n    lastTilt = currentTilt;\n\n}\n\nvoid Player::mouse_button_callback(GLFWwindow* window, int button, int action, int mods)\n{\n    if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS) \n    {\n        shooter.shootDefault(camera->transform.position, camera->transform.getForward(), camera->transform.getUp());\n    }\n}\n\nvoid Player::updateCameraPosition() \n{\n    camera->transform.position = transform.position;\n}",
    "movementh": "#pragma once\n\n#include<glew/glew.h>\n#include <GLFW/glfw3.h>\n#include <glm/glm.hpp>\n#include \"Transform.h\"\n#include \"Camera.h\"\n#include \"Entity.h\"\n#include \"Physicsbody.h\"\n#include \"shooting/Shooter.h\"\n\nclass Camera;\n\nclass Player : public Entity\n{\npublic:\n\tPlayer(Camera* camera);\n\n\tvoid update(GLFWwindow* window, float deltaTime);\n\tvoid processKeyboard(GLFWwindow* window, float deltaTime);\n\tvoid tiltCamera(GLFWwindow* window, float deltaTime);\n\tvoid mouse_button_callback(GLFWwindow* window, int button, int action, int mods);\n\tvoid updateCameraPosition();\n\tvoid checkCollision();\n\n\tCamera* getCamera() const { return camera; }\n\n\tfloat playerHeight = transform.scale.y / 2;\n\tfloat speed = 1600;\n\nprivate:\n\tPhysicsbody physicsbody;\n\tCamera* camera;\n\n\tglm::vec3 lastVelocity = glm::vec3(0.0f);\n\tbool canDash = true;\n\tfloat dashCooldown = 2.0f;\n\tfloat dashCooldownTimer = 0.0f;\n};",
    "trail": "void TrailMesh::addVertice(const glm::vec3 newVertice)\n{\n\tverticesVector.push_back(newVertice.x);\n\tverticesVector.push_back(newVertice.y);\n\tverticesVector.push_back(newVertice.z);\n\n\tif (verticesVector.size() > maxTrailPoints * 3)\n\t{\n\t\tverticesVector.erase(verticesVector.begin(), verticesVector.begin() + 3);\n\t}\n\n\t// update VBO with new data\n\tVBO->Bind();\n\tglBufferData(GL_ARRAY_BUFFER, verticesVector.size() * sizeof(float), verticesVector.data(), GL_DYNAMIC_DRAW);\n\tverticesCount = verticesVector.size() / 3;\n}",
    "gameh": "#pragma once\n#include \"Entity.h\"\n#include \"Transform.h\"\n#include \"../engine/Timer.h\"\n#include \"xp/XP.h\"\n\n#include <iostream>\n\n#define MAX_ENTITYS 1000\n\nclass Game\n{\npublic:\n\tvoid update();\n\tvoid render();\n\n    // spawn an entity of type \"EntityType\" at the given position with the given meshRenderer\n    template<typename EntityType>\n    EntityType* spawn_entity(glm::vec3 position, MeshRenderer meshRenderer)\n    {\n        for (int i = 0; i < MAX_ENTITYS; ++i)\n        {\n            if (entitys[i] == nullptr)\n            {\n                EntityType* new_entity = new EntityType(position, meshRenderer);\n                entitys[i] = new_entity;\n\n                return new_entity;\n            }\n        }\n        std::cerr << \"Entity array is full, cannot spawn more entities.\" << std::endl;\n        return nullptr;\n    }\n\n    void spawnXP(glm::vec3 position, int xpamount) \n    {\n        MeshRenderer xpMesh(cubeEnemyMesh, cubeEnemyShader, camera);\n\n        for(int i = 0; i < xpamount; i++)\n\t\t{\n\t\t\tspawn_entity<XP>(position, xpMesh);\n\t\t}\n    }\n\n    Game()\n    {\n        for (int i = 0; i < MAX_ENTITYS; ++i)\n        {\n            entitys[i] = nullptr;  // initialize all pointers to nullptr\n        }\n    }\n\n    // destructor to delete all entities when the game is destroyed to prevent memory leaks\n    ~Game()\n    {\n        for (int i = 0; i < MAX_ENTITYS; ++i)\n        {\n            delete entitys[i];\n            entitys[i] = nullptr;\n        }\n    }\n\n    Entity* get_coliding_entity(Entity* other, Collision_Channel channel);\n\n    void setMeshRenderer(Mesh* cardMesh, Shader* cardShader, Camera* camera);\n    void timer_callback();\n\n    float deltaTime = 0.f;\n    float lastFrameTime = 0.f;\n\n    Mesh* cubeEnemyMesh;\n    Shader* cubeEnemyShader;\n    Camera* camera;\n\n    int playerScore = 0;\n\nprivate:\n\tEntity* entitys[MAX_ENTITYS] = { nullptr };\n\n    Timer timer;\n\n\tbool spawnEnemy = true;\n};\n\nextern Game* game;",
    "game": "#include <iostream>\n\n#include \"Game.h\"\n#include \"Player.h\"\n#include \"AABB.h\"\n#include \"../graphics/MeshRenderer.h\"\n#include \"../graphics/Mesh.h\"\n#include \"../graphics/Shader.h\"\n#include \"enemies/CubeEnemy.h\"\n\nvoid Game::update() \n{\n\tdouble currentFrame = glfwGetTime();\n\tdeltaTime = currentFrame - lastFrameTime;\n\tlastFrameTime = currentFrame;\n\n\t// updates all the entitys\n\tfor (int i = 0; i < MAX_ENTITYS; i++) \n\t{\n\t\tif (entitys[i] != nullptr)\n\t\t{\n\t\t\tif (entitys[i]->destroyed)\n\t\t\t{\n\t\t\t\tdelete entitys[i];\n\t\t\t\tentitys[i] = nullptr;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tentitys[i]->update(deltaTime);\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif (spawnEnemy) {\n\n\t\t// spawn a new enemy when the timer reaches zero\n\t\tif (timer.isZero())\n\t\t{\n\t\t\ttimer.setTimer(250);\n\t\t\ttimer.setCallback([this]() { this->timer_callback(); });\n\t\t}\n\n\t\ttimer.updateTimer(deltaTime);\n\t}\n}\n\n// callback function for the timer\nvoid Game::timer_callback()\n{\n\tMeshRenderer newMeshRenderer(cubeEnemyMesh, cubeEnemyShader, camera);\n\tEntity* newEnemy = game->spawn_entity<CubeEnemy>(glm::vec3(1), newMeshRenderer);\n\tnewEnemy->transform.position = camera->transform.position + newEnemy->transform.getRandomPointInRadius(10, 25);\n}\n\n// calls the draw function on all the entities\nvoid Game::render()\n{\n\tfor (int i = 0; i < MAX_ENTITYS; i++)\n\t{\n\t\tif (entitys[i] != nullptr)\n\t\t{\n\t\t\tentitys[i]->draw();\n\t\t}\n\t}\n}\n\n// compares the bounding boxes of all the entities to see if they are overlapping\nEntity* Game::get_coliding_entity(Entity* other, Collision_Channel channel) \n{\n\tfor (int i = 0; i < MAX_ENTITYS; i++) \n\t{\n\t\tif (entitys[i] == other || entitys[i] == nullptr || entitys[i]->collision_channel != channel)\n\t\t\tcontinue;\n\n\t\tAABB a = AABB::from_position_size(other->transform);\n\t\tAABB b = AABB::from_position_size(entitys[i]->transform);\n\n\t\tif (aabb_overlap(a, b)) {\n\t\t\treturn entitys[i];\n\t\t}\n\t}\n\n\treturn nullptr;\n}"
}
