{
    "terrainh": "#pragma once\n\n#include <glm.hpp>\n#include <glfw3.h>\n#include <glad/glad.h>\n\n#include <vector>\n\n#include \"shaders/Shader.h\"\n#include \"Renderer.h\"\n\nclass Terrain {\npublic:\n    Terrain(glm::vec2 spawnPos, Shader* shader, Renderer* renderer);\n    ~Terrain();\n\n    void generate_terrain(int width, int height);\n    void addVoxel(glm::vec2 rawPos);\n    float get_height(int x, int y);\n\n    void spawn_tree(glm::vec2 spawnPos);\n\n    std::vector<GLfloat> vertices;\n    std::vector<GLuint> indices;\n\n    std::vector<glm::vec3> spawnedTrees;\n\n    glm::vec2 spawnPos;\n\n    Shader* shader;\n    Renderer* renderer;\n\nprivate:\n    float voxelSize = 1.0f;\n    int width = 50;\n    int height = 50;\n};",
    "terraincpp": "#include \"Terrain.h\"\n\n#include <cstdlib>\n#include <ctime>\n#include <gtc/noise.hpp>\n#include <iostream>\n\n#include \"Renderer.h\"\n#include \"MeshRenderer.h\"\n\n#include \"../src/rendering/OBJLoader.h\"\n#include \"../src/rendering/TextureLoader.h\"\n\nTerrain::Terrain(glm::vec2 spawnPos, Shader* shader, Renderer* renderer)\n    : spawnPos(spawnPos), shader(shader), renderer(renderer) {\n    generate_terrain(width, height);\n}\n\nTerrain::~Terrain() {}\n\nvoid Terrain::generate_terrain(int width, int height) {\n    vertices.clear();\n    indices.clear();\n\n    srand(time(nullptr));\n\n    vertices.reserve(width * height * 8);\n    indices.reserve(width * height * 6);\n\n    for (int x = 0; x < width; x++) {\n        for (int y = 0; y < height; y++) {\n            glm::vec2 posWithOffset = glm::vec2(x - (width / 2), y - (height / 2));\n            addVoxel(posWithOffset);\n            spawn_tree(posWithOffset);\n        }\n    }\n}\n\nvoid Terrain::addVoxel(glm::vec2 rawPos) {\n    GLfloat halfVoxelSize = voxelSize * 0.5f;\n    float terrainHeight = glm::round(get_height(rawPos.x, rawPos.y));\n\n    glm::vec3 basePosition(\n        rawPos.x * voxelSize,\n        terrainHeight * voxelSize,\n        rawPos.y * voxelSize);\n\n    std::vector<GLfloat> cubeVertices;\n\n    auto lambda = [this, &terrainHeight](glm::vec2 neighbourPosition) {\n        return get_height(neighbourPosition.x, neighbourPosition.y) < terrainHeight;\n    };\n\n    // always apply top face y+\ncubeVertices.insert(cubeVertices.end(), {\n        basePosition.x - halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z - halfVoxelSize, 0.0f, 0.0f,  0.0f,  1.0f,  0.0f, // Bottom-left\n        basePosition.x + halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z - halfVoxelSize, 1.0f, 0.0f,  0.0f,  1.0f,  0.0f, // Bottom-right\n        basePosition.x + halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z + halfVoxelSize, 1.0f, 1.0f,  0.0f,  1.0f,  0.0f, // Top-right\n        basePosition.x - halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z + halfVoxelSize, 0.0f, 1.0f,  0.0f,  1.0f,  0.0f  // Top-left\n    });\n    // front face z-\n    if (lambda(glm::vec2(rawPos.x, rawPos.y - 1))) {\n        cubeVertices.insert(cubeVertices.end(), {\n            basePosition.x - halfVoxelSize, basePosition.y - halfVoxelSize, basePosition.z - halfVoxelSize, 0.0f, 0.0f,  0.0f,  0.0f, -1.0f,\n            basePosition.x + halfVoxelSize, basePosition.y - halfVoxelSize, basePosition.z - halfVoxelSize, 1.0f, 0.0f,  0.0f,  0.0f, -1.0f,\n            basePosition.x + halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z - halfVoxelSize, 1.0f, 1.0f,  0.0f,  0.0f, -1.0f,\n            basePosition.x - halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z - halfVoxelSize, 0.0f, 1.0f,  0.0f,  0.0f, -1.0f\n        });\n    }\n    // back face z+\n    if (lambda(glm::vec2(rawPos.x, rawPos.y + 1))) {\n        cubeVertices.insert(cubeVertices.end(), {\n            basePosition.x - halfVoxelSize, basePosition.y - halfVoxelSize, basePosition.z + halfVoxelSize, 0.0f, 0.0f,  0.0f,  0.0f,  1.0f,\n            basePosition.x + halfVoxelSize, basePosition.y - halfVoxelSize, basePosition.z + halfVoxelSize, 1.0f, 0.0f,  0.0f,  0.0f,  1.0f,\n            basePosition.x + halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z + halfVoxelSize, 1.0f, 1.0f,  0.0f,  0.0f,  1.0f,\n            basePosition.x - halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z + halfVoxelSize, 0.0f, 1.0f,  0.0f,  0.0f,  1.0f\n        });\n    }\n    // right face x+\n    if (lambda(glm::vec2(rawPos.x + 1, rawPos.y))) {\n        cubeVertices.insert(cubeVertices.end(), {\n            basePosition.x + halfVoxelSize, basePosition.y - halfVoxelSize, basePosition.z - halfVoxelSize, 0.0f, 0.0f,  1.0f,  0.0f,  0.0f,\n            basePosition.x + halfVoxelSize, basePosition.y - halfVoxelSize, basePosition.z + halfVoxelSize, 1.0f, 0.0f,  1.0f,  0.0f,  0.0f,\n            basePosition.x + halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z + halfVoxelSize, 1.0f, 1.0f,  1.0f,  0.0f,  0.0f,\n            basePosition.x + halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z - halfVoxelSize, 0.0f, 1.0f,  1.0f,  0.0f,  0.0f\n        });\n    }\n    // left face x-\n    if (lambda(glm::vec2(rawPos.x - 1, rawPos.y))) {\n        cubeVertices.insert(cubeVertices.end(), {\n            basePosition.x - halfVoxelSize, basePosition.y - halfVoxelSize, basePosition.z - halfVoxelSize, 0.0f, 0.0f, -1.0f,  0.0f,  0.0f,\n            basePosition.x - halfVoxelSize, basePosition.y - halfVoxelSize, basePosition.z + halfVoxelSize, 1.0f, 0.0f, -1.0f,  0.0f,  0.0f,\n            basePosition.x - halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z + halfVoxelSize, 1.0f, 1.0f, -1.0f,  0.0f,  0.0f,\n            basePosition.x - halfVoxelSize, basePosition.y + halfVoxelSize, basePosition.z - halfVoxelSize, 0.0f, 1.0f, -1.0f,  0.0f,  0.0f\n        });\n    }\n\n    vertices.insert(vertices.end(), cubeVertices.begin(), cubeVertices.end());\n\n    std::vector<GLuint> faceIndices = { 0, 1, 2, 2, 3, 0 };\n\n    GLuint offset = (vertices.size() / 8) - 24;\n    for (int i = 0; i < 6; i++) {\n        std::vector<GLuint> face = faceIndices;\n        for (auto& index : face) index += offset + (i * 4);\n        indices.insert(indices.end(), face.begin(), face.end());\n    }\n}\n\nfloat Terrain::get_height(int x, int y) {\n    float scale = 0.02f;\n    float amplitude = 10.0f;\n\n    float noise = glm::perlin((spawnPos + glm::vec2(x, y)) * scale);\n    float height = noise * amplitude;\n\n    return glm::round(height);\n}\n\nvoid Terrain::spawn_tree(glm::vec2 spawnPosTree) {\n    float scale = 0.015f;\n    float amplitude = 10.0f;\n    float minDistance = 7.0f;\n\n    float noise = glm::perlin((spawnPos + spawnPosTree) * scale);\n\n    if (noise < -0.5f) {\n        bool tooClose = false;\n        for (const auto& tree : spawnedTrees) {\n            float distance = glm::length(glm::vec2(tree.x - spawnPos.x - spawnPosTree.x, tree.z - spawnPos.y - spawnPosTree.y));\n            if (distance < minDistance) {\n                tooClose = true;\n                break;\n            }\n        }\n\n        if (tooClose) return;\n\n        MeshRenderer* cubeMesh = OBJLoader::get_instance().load_mesh(\"tree\", shader);\n\n        if (cubeMesh) {\n            cubeMesh->apply_texture(TextureLoader::get_instance().get_texture(\"tree.png\"));\n            cubeMesh->renderer = renderer;\n            renderer->meshes.push_back(cubeMesh);\n\n            float yHeight = get_height(spawnPosTree.x, spawnPosTree.y);\n            cubeMesh->setPosition(glm::vec3(spawnPos.x + spawnPosTree.x, yHeight * voxelSize, spawnPos.y + spawnPosTree.y));\n\n            spawnedTrees.push_back(glm::vec3(spawnPos.x + spawnPosTree.x, yHeight, spawnPos.y + spawnPosTree.y));\n        }\n    }\n}"
}