{
    "boomerangh": "#pragma once\n\n#include \"Actor.h\"\n\nclass Boomerang : public Actor\n{\npublic:\n\tBoomerang();\n\n\tvoid update(float dt);\n\tvoid render(SDL_Renderer* renderer, Camera* camera) override;\n\n\tvoid check_overlap();\n\n\tfloat get_bounce_dir();\n\tvoid launch_boomerang(glm::vec2 dir, float speed);\n\tvoid visualise_trajectory(SDL_Renderer* renderer, Camera* camera);\n\n\tfloat projectileSpeed = 0.0f;\n\nprivate:\n\tfloat visualRotation = 0.0f;\n\tconst float rayLength = 1000.0f;\n};",
    "boomerang": "#include \"Boomerang.h\"\n\n#include \"../../Game.h\"\n\n#include \"../../engine/DebugDraw.h\"\n#include \"../../engine/Linetrace.h\"\n#include \"../../engine/LineHit.h\"\n\nBoomerang::Boomerang() {\n\ttexture = textureManager->getTexture(\"boomerang\");\n\n\tcollision_channel = Collision_Channel::P_Projectile;\n\trender_layer = Render_Layer::Entities;\n\n\tgame->layers[static_cast<size_t>(render_layer)].push_back(this);\n}\n\nvoid Boomerang::update(float dt) {\n\ttransform.position += (transform.get_transform_up() * projectileSpeed) * dt;\n\n\tvisualRotation += projectileSpeed * dt;\n\n\tprojectileSpeed = projectileSpeed >= 0 ? projectileSpeed = 0.0f : projectileSpeed -= 200.0f * dt;\n\n\tcheck_overlap();\n}\n\nvoid Boomerang::render(SDL_Renderer* renderer, Camera* camera) {\n\tSDL_Rect srcR = { 0, 0, 32, 32 };\n\tSDL_Rect destR = { transform.position.x - camera->x, transform.position.y - camera->y, 36, 36 };\n\n\tSDL_RenderCopyEx(renderer, texture, &srcR, &destR, visualRotation, NULL, SDL_FLIP_NONE);\n\n}\n\nvoid Boomerang::check_overlap() {\n\tActor* hitGroundActor = game->get_overlapping_actor(this, Collision_Channel::Ground);\n\tif (hitGroundActor != nullptr) {\n\t\tauto smallParticles = new ParticleController(transform.position + (transform.scale * 0.5f), textureManager->getTexture(\"effect2\"), 30, 25, 250, 0.25f);\n\t\tgame->spawn_particle_system(smallParticles);\n\n\t\tauto bigParticle = new ParticleController(transform.position + (transform.scale * 0.5f), textureManager->getTexture(\"effect\"), 1, 80, 0, 0.5f);\n\t\tgame->spawn_particle_system(bigParticle);\n\n\t\ttransform.rotation.x = get_bounce_dir();\n\t\t\n\t\tprojectileSpeed += 10;\n\t}\n\n\tActor* hitPlayerActor = game->get_overlapping_actor(this, Collision_Channel::Player);\n\tif (hitPlayerActor != nullptr) {\n\t\tgame->player->pick_up(this);\n\t}\n}\n\nfloat Boomerang::get_bounce_dir() {\n\tglm::vec2 origin = transform.position;\n\tglm::vec2 dir = transform.get_transform_up();\n\t\n\tLinetrace linetrace;\n\tLineHit result = linetrace.line_trace(origin, dir, Collision_Channel::Ground, 200);\n\t\n\tif (result.hit_point == origin) return;\n\n\tif (result.hit_actor != nullptr) {\n\t    glm::vec2 incomingRay = glm::normalize(result.hit_point - origin);\n\t    glm::vec2 reflection = incomingRay - result.normal * (2.0f * glm::dot(incomingRay, result.normal));\n\t\n\t    dir = reflection;\n\t    origin = result.hit_point;\n\n\t\tfloat angle = glm::degrees(atan2(dir.y, dir.x));\n\t\tif (angle < 0) {\n\t\t\tangle += 360;\n\t\t}\n\n\t\treturn angle;\n\t}\n}\n\nvoid Boomerang::visualise_trajectory(SDL_Renderer* renderer, Camera* camera) {\n\tglm::vec2 origin = transform.position;\n\tglm::vec2 dir = transform.get_transform_up();\n\n    Linetrace linetrace;\n    LineHit result = linetrace.line_trace(origin, dir, Collision_Channel::Ground, rayLength);\n\n    if (result.hit_point != origin) {\n\t\tSDL_SetRenderDrawColor(renderer, 255, 120, 0, 255);\n\n        SDL_RenderDrawLine(renderer, origin.x - camera->x + 16, origin.y - camera->y + 16,\n            result.hit_point.x - camera->x + 16, result.hit_point.y - camera->y + 16);\n\n        if (result.hit_actor != nullptr) {\n\n            glm::vec2 normalStart = result.hit_point;\n            glm::vec2 normalEnd = normalStart - result.normal * 50.0f;\n\n            // draw the normal\n            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);\n            SDL_RenderDrawLine(renderer,\n\t\t\t\tnormalStart.x - camera->x + 16,\n\t\t\t\tnormalStart.y - camera->y + 16,\n\t\t\t\tnormalEnd.x - camera->x + 16,\n\t\t\t\tnormalEnd.y - camera->y + 16);\n\n            // reflected ray calculation\n            glm::vec2 incomingRay = glm::normalize(result.hit_point - origin);\n            glm::vec2 reflection = incomingRay - result.normal * (2.0f * glm::dot(incomingRay, result.normal));\n            glm::vec2 reflectionEnd = result.hit_point + reflection * 500.0f;\n\n            // draw ray\n            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);\n            SDL_RenderDrawLine(renderer,\n                result.hit_point.x - camera->x + 16,\n                result.hit_point.y - camera->y + 16,\n\t\t\t\treflectionEnd.x - camera->x + 16,\n\t\t\t\treflectionEnd.y - camera->y + 16);\n        }\n    }\n\n\tSDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);\n}\n\nvoid Boomerang::launch_boomerang(glm::vec2 dir, float speed) {\n\tfloat angleInDegrees = glm::degrees(atan2(dir.y, dir.x));\n\n\tprojectileSpeed = speed;\n\ttransform.rotation.x = angleInDegrees;\n\ttransform.position += dir * 50.0f;\n}",
    "particlecontrollerh": "#pragma once\n\n#include <glm.hpp>\n\n#include \"Particle.h\"\n\nconst int MAX_PARTICLES = 200;\n\nclass ParticleController\n{\npublic:\n\tParticleController(glm::vec2 pos, SDL_Texture* texture, int maxParticles = 25, int inScale = 5, int spd = 400, float dur = 0.2f);\n\n\tvoid render(SDL_Renderer* renderer);\n\n\tbool is_empty();\n\nprivate:\n\tstd::vector<Particle*> particleList[MAX_PARTICLES];\n};",
    "particlecontroller": "#include \"ParticleController.h\"\n\nParticleController::ParticleController(glm::vec2 pos, SDL_Texture* texture, int maxParticles, int inScale, int spd, float dur)\n{\n\tfor (int i = 0; i < maxParticles; i++) {\n\t\tif (i >= MAX_PARTICLES)\n\t\t\tbreak;\n\n\t\tif (texture == nullptr) return;\n\n\t\tauto newParticle = new Particle(pos, texture, inScale, spd, dur);\n\t\tparticleList[i].push_back(newParticle);\n\t}\n}\n\nvoid ParticleController::render(SDL_Renderer* renderer)\n{\n\tfor (int i = 0; i < MAX_PARTICLES; ++i) {\n\t\tfor (auto particle : particleList[i]) {\n\t\t\tif (particle == nullptr)\n\t\t\t\treturn;\n\n\t\t\tif (particle->isDestroyed()) {\n\t\t\t\tparticleList->at(i) = nullptr;\n\t\t\t\tdelete particle;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tparticle->render(renderer);\n\t\t}\n\t}\n}\n\nbool ParticleController::is_empty()\n{\n\tfor (const auto& particles : particleList) {\n\t\tfor (const auto& particle : particles) {\n\t\t\tif (particle != nullptr && !particle->isDestroyed()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}",
    "particleh": "#pragma once\n\n#include <glm.hpp>\n#include <SDL.h>\n#include <random>\n\n#include \"../game/components/location/Transform.h\"\n\nclass Particle\n{\npublic:\n\tParticle(glm::vec2 position, SDL_Texture* texture, int inScale, int spd, float dur);\n\n\tvoid render(SDL_Renderer* renderer);\n\n\tbool isDestroyed() { \n\t\treturn bDestroyed; \n\t};\n\n\tbool bDestroyed = false;\n\nprivate:\n\tSDL_Texture* m_texture;\n\t\n\tglm::vec2 pos;\n\n\tfloat rot;\n\tfloat scale;\n\tfloat initialScale;\n\n\tfloat speed;\n\tfloat duration;\n\tfloat currentDuration;\n};",
    "particle": "#include \"Particle.h\"\n\n#include \"../engine/zmath.h\"\n\n#include \"../Game.h\"\n\nParticle::Particle(glm::vec2 position, SDL_Texture* texture, int inScale, int spd, float dur)\n\t: pos(position), speed(spd), duration(dur)\n{\n\trot = rand() % 361;\n\n\tinitialScale = rand() % inScale + 4;\n\tscale = initialScale;\n\tcurrentDuration = duration;\n\n\tm_texture = texture;\n}\n\nvoid Particle::render(SDL_Renderer* renderer)\n{\n\tbDestroyed = currentDuration <= 0 || (currentDuration -= game->deltaTime, false);\n\n\tscale = initialScale * zmath::EaseOutCubicBounce(1 - (currentDuration / duration)) + 1;\n\n\tfloat radians = glm::radians(rot);\n\tglm::vec2 upVector = glm::vec2(std::cos(radians), std::sin(radians));\n\n\tpos += upVector * game->deltaTime * speed;\n\t\n\tSDL_Rect srcR = { 0, 0, 32, 32 };\n\tSDL_Rect destR = { pos.x - game->camera->x - scale / 2, pos.y - game->camera->y - scale / 2, scale, scale };\n\n\tSDL_RenderCopyEx(renderer, m_texture, &srcR, &destR, rot, NULL, SDL_FLIP_NONE);\n}"
}
