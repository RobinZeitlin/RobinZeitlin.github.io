{
    "boomerangh": "#pragma once\n\n#include \"Actor.h\"\n\nclass Boomerang : public Actor\n{\npublic:\n\tBoomerang();\n\n\tvoid update(float dt);\n\tvoid render(SDL_Renderer* renderer, Camera* camera) override;\n\n\tvoid check_overlap();\n\n\tfloat get_bounce_dir();\n\tvoid launch_boomerang(glm::vec2 dir, float speed);\n\tvoid visualise_trajectory(SDL_Renderer* renderer, Camera* camera);\n\n\tfloat projectileSpeed = 0.0f;\n\nprivate:\n\tfloat visualRotation = 0.0f;\n\tconst float rayLength = 1000.0f;\n};",
    "boomerang": "#include \"Boomerang.h\"\n\n#include \"../../Game.h\"\n\n#include \"../../engine/DebugDraw.h\"\n#include \"../../engine/Linetrace.h\"\n#include \"../../engine/LineHit.h\"\n\nBoomerang::Boomerang() {\n\ttexture = textureManager->getTexture(\"boomerang\");\n\n\tcollision_channel = Collision_Channel::P_Projectile;\n\trender_layer = Render_Layer::Entities;\n\n\tgame->layers[static_cast<size_t>(render_layer)].push_back(this);\n}\n\nvoid Boomerang::update(float dt) {\n\ttransform.position += (transform.get_transform_up() * projectileSpeed) * dt;\n\n\tvisualRotation += projectileSpeed * dt;\n\n\tprojectileSpeed = projectileSpeed >= 0 ? projectileSpeed = 0.0f : projectileSpeed -= 200.0f * dt;\n\n\tcheck_overlap();\n}\n\nvoid Boomerang::render(SDL_Renderer* renderer, Camera* camera) {\n\tSDL_Rect srcR = { 0, 0, 32, 32 };\n\tSDL_Rect destR = { transform.position.x - camera->x, transform.position.y - camera->y, 36, 36 };\n\n\tSDL_RenderCopyEx(renderer, texture, &srcR, &destR, visualRotation, NULL, SDL_FLIP_NONE);\n\n}\n\nvoid Boomerang::check_overlap() {\n\tActor* hitGroundActor = game->get_overlapping_actor(this, Collision_Channel::Ground);\n\tif (hitGroundActor != nullptr) {\n\t\tauto smallParticles = new ParticleController(transform.position + (transform.scale * 0.5f), textureManager->getTexture(\"effect2\"), 30, 25, 250, 0.25f);\n\t\tgame->spawn_particle_system(smallParticles);\n\n\t\tauto bigParticle = new ParticleController(transform.position + (transform.scale * 0.5f), textureManager->getTexture(\"effect\"), 1, 80, 0, 0.5f);\n\t\tgame->spawn_particle_system(bigParticle);\n\n\t\ttransform.rotation.x = get_bounce_dir();\n\t\t\n\t\tprojectileSpeed += 10;\n\t}\n\n\tActor* hitPlayerActor = game->get_overlapping_actor(this, Collision_Channel::Player);\n\tif (hitPlayerActor != nullptr) {\n\t\tgame->player->pick_up(this);\n\t}\n}\n\nfloat Boomerang::get_bounce_dir() {\n\tglm::vec2 origin = transform.position;\n\tglm::vec2 dir = transform.get_transform_up();\n\t\n\tLinetrace linetrace;\n\tLineHit result = linetrace.line_trace(origin, dir, Collision_Channel::Ground, 200);\n\t\n\tif (result.hit_point == origin) return;\n\n\tif (result.hit_actor != nullptr) {\n\t    glm::vec2 incomingRay = glm::normalize(result.hit_point - origin);\n\t    glm::vec2 reflection = incomingRay - result.normal * (2.0f * glm::dot(incomingRay, result.normal));\n\t\n\t    dir = reflection;\n\t    origin = result.hit_point;\n\n\t\tfloat angle = glm::degrees(atan2(dir.y, dir.x));\n\t\tif (angle < 0) {\n\t\t\tangle += 360;\n\t\t}\n\n\t\treturn angle;\n\t}\n}\n\nvoid Boomerang::visualise_trajectory(SDL_Renderer* renderer, Camera* camera) {\n\tglm::vec2 origin = transform.position;\n\tglm::vec2 dir = transform.get_transform_up();\n\n    Linetrace linetrace;\n    LineHit result = linetrace.line_trace(origin, dir, Collision_Channel::Ground, rayLength);\n\n    if (result.hit_point != origin) {\n\t\tSDL_SetRenderDrawColor(renderer, 255, 120, 0, 255);\n\n        SDL_RenderDrawLine(renderer, origin.x - camera->x + 16, origin.y - camera->y + 16,\n            result.hit_point.x - camera->x + 16, result.hit_point.y - camera->y + 16);\n\n        if (result.hit_actor != nullptr) {\n\n            glm::vec2 normalStart = result.hit_point;\n            glm::vec2 normalEnd = normalStart - result.normal * 50.0f;\n\n            // draw the normal\n            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);\n            SDL_RenderDrawLine(renderer,\n\t\t\t\tnormalStart.x - camera->x + 16,\n\t\t\t\tnormalStart.y - camera->y + 16,\n\t\t\t\tnormalEnd.x - camera->x + 16,\n\t\t\t\tnormalEnd.y - camera->y + 16);\n\n            // reflected ray calculation\n            glm::vec2 incomingRay = glm::normalize(result.hit_point - origin);\n            glm::vec2 reflection = incomingRay - result.normal * (2.0f * glm::dot(incomingRay, result.normal));\n            glm::vec2 reflectionEnd = result.hit_point + reflection * 500.0f;\n\n            // draw ray\n            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);\n            SDL_RenderDrawLine(renderer,\n                result.hit_point.x - camera->x + 16,\n                result.hit_point.y - camera->y + 16,\n\t\t\t\treflectionEnd.x - camera->x + 16,\n\t\t\t\treflectionEnd.y - camera->y + 16);\n        }\n    }\n\n\tSDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);\n}\n\nvoid Boomerang::launch_boomerang(glm::vec2 dir, float speed) {\n\tfloat angleInDegrees = glm::degrees(atan2(dir.y, dir.x));\n\n\tprojectileSpeed = speed;\n\ttransform.rotation.x = angleInDegrees;\n\ttransform.position += dir * 50.0f;\n}",
    "particlecontrollerh": "#pragma once\n\n#include <glm.hpp>\n\n#include \"Particle.h\"\n\nconst int MAX_PARTICLES = 200;\n\nclass ParticleController\n{\npublic:\n\tParticleController(glm::vec2 pos, SDL_Texture* texture, int maxParticles = 25, int inScale = 5, int spd = 400, float dur = 0.2f);\n\n\tvoid render(SDL_Renderer* renderer);\n\n\tbool is_empty();\n\nprivate:\n\tstd::vector<Particle*> particleList[MAX_PARTICLES];\n};",
    "particlecontroller": "#include \"ParticleController.h\"\n\nParticleController::ParticleController(glm::vec2 pos, SDL_Texture* texture, int maxParticles, int inScale, int spd, float dur)\n{\n\tfor (int i = 0; i < maxParticles; i++) {\n\t\tif (i >= MAX_PARTICLES)\n\t\t\tbreak;\n\n\t\tif (texture == nullptr) return;\n\n\t\tauto newParticle = new Particle(pos, texture, inScale, spd, dur);\n\t\tparticleList[i].push_back(newParticle);\n\t}\n}\n\nvoid ParticleController::render(SDL_Renderer* renderer)\n{\n\tfor (int i = 0; i < MAX_PARTICLES; ++i) {\n\t\tfor (auto particle : particleList[i]) {\n\t\t\tif (particle == nullptr)\n\t\t\t\treturn;\n\n\t\t\tif (particle->isDestroyed()) {\n\t\t\t\tparticleList->at(i) = nullptr;\n\t\t\t\tdelete particle;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tparticle->render(renderer);\n\t\t}\n\t}\n}\n\nbool ParticleController::is_empty()\n{\n\tfor (const auto& particles : particleList) {\n\t\tfor (const auto& particle : particles) {\n\t\t\tif (particle != nullptr && !particle->isDestroyed()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}",
    "particleh": "#pragma once\n\n#include <glm.hpp>\n#include <SDL.h>\n#include <random>\n\n#include \"../game/components/location/Transform.h\"\n\nclass Particle\n{\npublic:\n\tParticle(glm::vec2 position, SDL_Texture* texture, int inScale, int spd, float dur);\n\n\tvoid render(SDL_Renderer* renderer);\n\n\tbool isDestroyed() { \n\t\treturn bDestroyed; \n\t};\n\n\tbool bDestroyed = false;\n\nprivate:\n\tSDL_Texture* m_texture;\n\t\n\tglm::vec2 pos;\n\n\tfloat rot;\n\tfloat scale;\n\tfloat initialScale;\n\n\tfloat speed;\n\tfloat duration;\n\tfloat currentDuration;\n};",
    "particle": "#include \"Particle.h\"\n\n#include \"../engine/zmath.h\"\n\n#include \"../Game.h\"\n\nParticle::Particle(glm::vec2 position, SDL_Texture* texture, int inScale, int spd, float dur)\n\t: pos(position), speed(spd), duration(dur)\n{\n\trot = rand() % 361;\n\n\tinitialScale = rand() % inScale + 4;\n\tscale = initialScale;\n\tcurrentDuration = duration;\n\n\tm_texture = texture;\n}\n\nvoid Particle::render(SDL_Renderer* renderer)\n{\n\tbDestroyed = currentDuration <= 0 || (currentDuration -= game->deltaTime, false);\n\n\tscale = initialScale * zmath::EaseOutCubicBounce(1 - (currentDuration / duration)) + 1;\n\n\tfloat radians = glm::radians(rot);\n\tglm::vec2 upVector = glm::vec2(std::cos(radians), std::sin(radians));\n\n\tpos += upVector * game->deltaTime * speed;\n\t\n\tSDL_Rect srcR = { 0, 0, 32, 32 };\n\tSDL_Rect destR = { pos.x - game->camera->x - scale / 2, pos.y - game->camera->y - scale / 2, scale, scale };\n\n\tSDL_RenderCopyEx(renderer, m_texture, &srcR, &destR, rot, NULL, SDL_FLIP_NONE);\n}",
    "splinecpp": "#include \"Spline.h\"\n\n#include <cmath>\n#include \"../zmath.h\"\n\n#include \"../../Game.h\"\n#include \"../DebugDraw.h\"\n\nvoid Spline::render_debug(SDL_Renderer* renderer)\n{\n\tfor (auto point : splinePoints) {\n\t\tpoint->render_point();\n\t}\n\n\tif (splinePoints.size() > 1) {\n\t\tinterpolateAmount = fmod(interpolateAmount + game->deltaTime, 1.0f);\n\n\t\tint splinePointSize = loopSpline ? splinePoints.size() : splinePoints.size() - 1;\n\n\t\tfor (size_t i = 0; i < splinePointSize; i++)\n\t\t{\n\t\t\tint nextPoint = (i + 1) % splinePoints.size();\n\n\t\t\tTransform a = splinePoints[i]->transform;\n\t\t\tTransform b = splinePoints[nextPoint]->transform;\n\n\t\t\tglm::vec2 aOffset = splinePoints[i]->handles->get_handle_a_offset();\n\t\t\tglm::vec2 aHandle = a.position + aOffset;\n\n\t\t\tglm::vec2 bOffset = splinePoints[nextPoint]->handles->get_handle_b_offset();\n\t\t\tglm::vec2 bHandle = b.position + bOffset;\n\n\t\t\tglm::vec2 interpolatedPos = zmath::cubic_lerp(a.position, aHandle, bHandle, b.position, interpolateAmount);\n\n\n\t\t\tint resolution = 10;\n\t\t\tglm::vec2 lastPointOnCurve = splinePoints[i]->transform.position;\n\t\t\tfor (size_t j = 0; j < resolution; j++) {\n\t\t\t\tSDL_SetRenderDrawColor(renderer, 234, 239, 44, 255);\n\t\t\t\tfloat t = static_cast<float>(j) / static_cast<float>(resolution - 1);\n\t\t\t\tglm::vec2 newPoint = zmath::cubic_lerp(a.position, aHandle, bHandle, b.position, t);\n\n\t\t\t\tSDL_RenderDrawLineF(renderer,\n\t\t\t\t\tlastPointOnCurve.x - game->camera->x,\n\t\t\t\t\tlastPointOnCurve.y - game->camera->y,\n\t\t\t\t\tnewPoint.x - game->camera->x,\n\t\t\t\t\tnewPoint.y - game->camera->y);\n\n\t\t\t\tlastPointOnCurve = newPoint;\n\t\t\t}\n\t\t}\n\t}\n\n\tSDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);\n}\n\nglm::vec2 Spline::get_global_position(float globalProgress)\n{\n\tglobalProgress = glm::clamp(globalProgress, 0.0f, 1.0f);\n\n\tfloat totalLength = 0.0f;\n\tstd::vector<float> segmentLengths;\n\n\tint splinePointSize = loopSpline ? splinePoints.size() : splinePoints.size() - 1;\n\n\tfor (size_t i = 0; i < splinePointSize; i++) {\n\t\tint nextPoint = (i + 1) % splinePoints.size();\n\n\t\tglm::vec2 a = splinePoints[i]->transform.position;\n\t\tglm::vec2 b = splinePoints[nextPoint]->transform.position;\n\n\t\tglm::vec2 aOffset = splinePoints[i]->handles->get_handle_a_offset();\n\t\tglm::vec2 aHandle = a + aOffset;\n\n\t\tglm::vec2 bOffset = splinePoints[nextPoint]->handles->get_handle_b_offset();\n\t\tglm::vec2 bHandle = b + bOffset;\n\n\t\tfloat segmentLength = 0.0f;\n\t\tglm::vec2 lastPoint = a;\n\t\tint resolution = 10;\n\n\t\tfor (size_t j = 1; j <= resolution; j++) {\n\t\t\tfloat t = static_cast<float>(j) / resolution;\n\t\t\tglm::vec2 point = zmath::cubic_lerp(a, aHandle, bHandle, b, t);\n\n\t\t\tsegmentLength += glm::distance(lastPoint, point);\n\t\t\tlastPoint = point;\n\t\t}\n\n\t\tsegmentLengths.push_back(segmentLength);\n\t\ttotalLength += segmentLength;\n\t}\n\n\tfloat targetLength = globalProgress * totalLength;\n\tfloat accumulatedLength = 0.0f;\n\n\tfor (size_t i = 0; i < splinePointSize; i++) {\n\t\tif (accumulatedLength + segmentLengths[i] >= targetLength) {\n\n\t\t\tfloat segmentProgress = (targetLength - accumulatedLength) / segmentLengths[i];\n\t\t\tint nextPoint = (i + 1) % splinePoints.size();\n\n\t\t\tglm::vec2 a = splinePoints[i]->transform.position;\n\t\t\tglm::vec2 b = splinePoints[nextPoint]->transform.position;\n\n\t\t\tglm::vec2 aOffset = splinePoints[i]->handles->get_handle_a_offset();\n\t\t\tglm::vec2 aHandle = a + aOffset;\n\n\t\t\tglm::vec2 bOffset = splinePoints[nextPoint]->handles->get_handle_b_offset();\n\t\t\tglm::vec2 bHandle = b + bOffset;\n\n\t\t\treturn zmath::cubic_lerp(a, aHandle, bHandle, b, segmentProgress);\n\t\t}\n\n\t\taccumulatedLength += segmentLengths[i];\n\t}\n\treturn splinePoints.back()->transform.position;\n}\n\nglm::vec2 Spline::get_closest_point_on_spline(glm::vec2 comparisonPos) {\n\tconst int resolution = 100;\n\n\tfloat closestDistance = std::numeric_limits<float>::max();\n\n\tglm::vec2 closestPoint;\n\tglm::vec2 points[resolution];\n\n\tfor (size_t i = 0; i < resolution; i++) {\n\t\tfloat splineProgress = static_cast<float>(i) / (resolution - 1);\n\n\t\tglm::vec2 positionOnSpline = get_global_position(splineProgress);\n\n\t\tfloat dist = zmath::get_distance(positionOnSpline, comparisonPos);\n\t\tif (dist < closestDistance) {\n\t\t\tclosestDistance = dist;\n\t\t\tclosestPoint = positionOnSpline;\n\t\t}\n\t}\n\n\treturn closestPoint;\n}",
    "splineh": "#pragma once\n\n#include <glm.hpp>\n#include \"../DebugDraw.h\"\n\n#include \"SplinePoint.h\"\n\nclass Spline\n{\npublic:\n\t~Spline() {\n\t\tfor (auto point : splinePoints)\n\t\t\tdelete point;\n\n\t\tclear_spline_points();\n\t}\n\n\tvoid render_debug(SDL_Renderer* renderer);\n\n\tvoid add_spline_point() {\n\t\tauto newPoint = new SplinePoint();\n\t\tnewPoint->transform.position = glm::vec2(100 * (splinePoints.size() + 1), 50 + 50 * (splinePoints.size() + 1));\n\n\t\tsplinePoints.push_back(newPoint);\n\t}\n\tvoid remove_spline_point() {\n\t\tif (!splinePoints.empty()) {\n\t\t\tdelete splinePoints.back();\n\t\t\tsplinePoints.pop_back();\n\t\t}\n\t}\n\n\tvoid clear_spline_points() {\n\t\twhile(!splinePoints.empty()) {\n\t\t\tdelete splinePoints.back();\n\t\t\tsplinePoints.pop_back();\n\t\t}\n\t}\n\n\tglm::vec2 get_global_position(float globalProgress);\n\tglm::vec2 get_closest_point_on_spline(glm::vec2 comparisonPos);\n\n\tstd::vector<SplinePoint*> splinePoints;\n\n\tfloat interpolateAmount;\n\n\tbool loopSpline;\n};",
    "splinepointcpp": "#include \"SplinePoint.h\"\n\n#include \"../../Game.h\"\n#include \"../../Camera.h\"\n\nSplinePoint::SplinePoint() {\n\ttransform.scale.x = 10.0f;\n\ttransform.rotation = glm::vec2(270, 0);\n\n\thandles = new SplineHandles(&this->transform);\n}\n\nSplinePoint::~SplinePoint()\n{\n\tdelete handles;\n}\n\nvoid SplinePoint::render_point()\n{\n\tauto renderer = game->renderer;\n\n\tif (game->levelEditor != nullptr) {\n\t\tif (game->levelEditor->selectedSplinePoint == this) {\n\t\t\tSDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);\n\n\t\t\tDebugDraw::draw_debug_sphere(renderer, glm::vec2(\n\t\t\t\ttransform.position.x - game->camera->x,\n\t\t\t\ttransform.position.y - game->camera->y),\n\t\t\t\ttransform.scale.x * 1.2f, 10);\n\n\t\t\trender_handle(renderer);\n\t\t}\n\t\telse {\n\t\t\tSDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);\n\n\t\t\tDebugDraw::draw_debug_sphere(renderer, glm::vec2(\n\t\t\t\ttransform.position.x - game->camera->x,\n\t\t\t\ttransform.position.y - game->camera->y),\n\t\t\t\ttransform.scale.x, 10);\n\t\t}\n\t}\n\telse {\n\t\tSDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);\n\n\t\tDebugDraw::draw_debug_sphere(renderer, glm::vec2(\n\t\t\ttransform.position.x - game->camera->x,\n\t\t\ttransform.position.y - game->camera->y),\n\t\t\ttransform.scale.x, 10);\n\t}\n}\nvoid SplinePoint::render_handle(SDL_Renderer* renderer)\n{\n\tif (handles == nullptr) return;\n\n\tSDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);\n\n\tglm::vec2 cameraPos = glm::vec2(game->camera->x, game->camera->y);\n\n\tDebugDraw::draw_debug_sphere(renderer, \n\t\ttransform.position + handles->get_handle_a_offset() - glm::vec2(game->camera->x, game->camera->y),\n\t\ttransform.scale.x * 0.6f, 10);\n\n\tDebugDraw::draw_debug_sphere(renderer, \n\t\ttransform.position + handles->get_handle_b_offset() - glm::vec2(game->camera->x, game->camera->y),\n\t\ttransform.scale.x * 0.6f, 10);\n\n\tglm::vec2 offsetB = transform.position + handles->get_handle_b_offset() - cameraPos;\n\tSDL_RenderDrawLineF(renderer,\n\t\ttransform.position.x - cameraPos.x,\n\t\ttransform.position.y - cameraPos.y,\n\t\toffsetB.x,\n\t\toffsetB.y);\n\n\tglm::vec2 offsetA = transform.position + handles->get_handle_a_offset() - cameraPos;\n\tSDL_RenderDrawLineF(renderer,\n\t\ttransform.position.x - cameraPos.x,\n\t\ttransform.position.y - cameraPos.y,\n\t\toffsetA.x,\n\t\toffsetA.y);\n}\n\nvoid SplinePoint::update_handles_and_rotation(glm::vec2 mousePos) {\n\tglm::vec2 thisPointPos = transform.position;\n\tfloat distance = transform.get_distance(thisPointPos, mousePos);\n\n\tglm::vec2 direction = glm::normalize(mousePos - thisPointPos);\n\tfloat angle = std::atan2(direction.y, direction.x);\n\ttransform.rotation.x = glm::degrees(angle);\n\n\thandles->distance = distance;\n}",
    "splinepointh": "#pragma once\n\n#include <SDL.h>\n\n#include \"glm.hpp\"\n\n#include \"SplineHandles.h\"\n\n#include \"../../game/components/location/Transform.h\"\n\nclass SplinePoint\n{\npublic:\n\tSplinePoint();\n\t~SplinePoint();\n\n\tvoid render_point();\n\tvoid render_handle(SDL_Renderer* renderer);\n\n\tvoid update_handles_and_rotation(glm::vec2 mousePos);\n\n\tvoid move_to(glm::vec2 newPos) { transform.position = newPos; }\n\n\tTransform transform;\n\n\tSplineHandles* handles = nullptr;\n};"
}
