{
    "parabolic": "// Main throw function.\n\nvoid UPlayerThrowComponent::Throw()\n{\n    UUUnitHandler* UnitHandlerRef = Cast<UUUnitHandler>(GetOwner()->GetComponentByClass(UUUnitHandler::StaticClass()));\n\n    if (UnitHandlerRef == nullptr)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"UnitHandler is null\"));\n        return;\n    }\n\n    if (UnitHandlerRef->CurrentUnits <= 0)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"No units to throw\"));\n        return;\n    }\n\n    if (!bReleaseToShoot && bIsAiming && bRayHit)\n    {\n        SpawnAndFollowProjectile(TrajectoryPoints);\n        UnitHandlerRef->CurrentUnits--;\n    }\n}\n\n// Calls Debugs and Raycast.\n\nvoid UPlayerThrowComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);\n    if (GEngine)\n    {\n        FColor DebugColor = bIsAiming ? FColor::Green : FColor::Red;\n        DrawDebugString(GetWorld(), FVector(0, 0, 100), bIsAiming ? \"Aiming\" : \"Not Aiming\", GetOwner(), DebugColor, 0.1f * DeltaTime);\n        DrawDebugString(GetWorld(), FVector(0, 0, 120), bReleaseToShoot ? \"Release to shoot\" : \"Hold & left click to shoot\", GetOwner(), FColor::White, 0.1f * DeltaTime);\n        DrawDebugString(GetWorld(), FVector(0, 0, 140), FString::Printf(TEXT(\"Throw Multiplier: %f\"), ThrowMultiplier), GetOwner(), FColor::White, 0.1f * DeltaTime);\n        DrawDebugString(GetWorld(), FVector(0, 0, 160), FString::Printf(TEXT(\"Range Multiplier: %f\"), ThrowRange), GetOwner(), FColor::White, 0.1f * DeltaTime);\n    }\n\n    if (bIsAiming)\n    {\n        Ray();\n\n        if (TrajectoryPoints.Num() > 0)\n        {\n            UpdateTrajectoryMaterials();\n            UpdateTrajectoryMeshes(TrajectoryPoints);\n        }\n    }\n}\n\n// Raycast from the player to the mouse position, also calculate player and camera distance\n\nvoid UPlayerThrowComponent::Ray()\n{\n    FVector2D MousePosition;\n    APlayerController* PlayerControllerRef = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\n    if (!PlayerControllerRef || !PlayerControllerRef->GetMousePosition(MousePosition.X, MousePosition.Y))\n    {\n        return;\n    }\n\n    FVector WorldLocation, WorldDirection;\n    if (!UGameplayStatics::DeprojectScreenToWorld(PlayerControllerRef, MousePosition, WorldLocation, WorldDirection))\n    {\n        return;\n    }\n\n    APlayerCameraManager* PlayerCamera = GetWorld()->GetFirstPlayerController()->PlayerCameraManager;\n    if (!PlayerCamera)\n    {\n        return;\n    }\n\n    FVector CameraLocation = PlayerCamera->GetCameraLocation();\n    float PlayerAndCameraDistance = FVector::Distance(PlayerControllerRef->GetPawn()->GetActorLocation(), CameraLocation);\n\n    FVector Start = WorldLocation;\n    FVector End = Start + WorldDirection * (ThrowRange + PlayerAndCameraDistance);\n\n    DrawDebugSphere(GetWorld(), GetOwner()->GetActorLocation(), ThrowRange, 8, FColor::Red, false, -1.f, 0);\n\n    FHitResult Hit;\n    TArray<AActor*> ActorsToIgnore = { GetOwner() };\n    TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes = {\n        UEngineTypes::ConvertToObjectType(ECC_WorldStatic),\n        UEngineTypes::ConvertToObjectType(ECC_Pawn)\n    };\n\n    bool ActorHit = UKismetSystemLibrary::LineTraceSingleForObjects(GetWorld(), Start, End, ObjectTypes, false, ActorsToIgnore, EDrawDebugTrace::None, Hit, true, FLinearColor::Red, FLinearColor::Green, 0.05f);\n\n    bRayHit = ActorHit;\n\n    if (ActorHit && Hit.GetActor())\n    {\n        float ThrowHeight = FVector::Distance(PlayerControllerRef->GetPawn()->GetActorLocation(), Hit.ImpactPoint) / 2 * ThrowMultiplier;\n        DrawThrowCurve(PlayerControllerRef->GetPawn()->GetActorLocation(), Hit.ImpactPoint, ThrowHeight, SmoothnessOfCurve, FColor::Green);\n    }\n    else\n    {\n        FVector MousePosAtEdge = Start + WorldDirection * ThrowRange;\n        float ThrowHeight = FVector::Distance(PlayerControllerRef->GetPawn()->GetActorLocation(), MousePosAtEdge) / 2 * ThrowMultiplier;\n        DrawThrowCurve(PlayerControllerRef->GetPawn()->GetActorLocation(), MousePosAtEdge, ThrowHeight, SmoothnessOfCurve, FColor::Red);\n    }\n}\n\n// Calculate the projectile trajectory.\n\nvoid UPlayerThrowComponent::DrawThrowCurve(const FVector& StartPoint, const FVector& EndPoint, float HeightOffset, int32 NumPoints, FColor Color)\n{\n    if (NumPoints < 2) return;\n\n    TArray<FVector> NewTrajectoryPoints;\n    NewTrajectoryPoints.Reserve(NumPoints);\n\n    NewTrajectoryPoints.Add(StartPoint);\n\n    float HeightOffset4 = 4.0f * HeightOffset;\n\n    for (int32 i = 1; i < NumPoints - 1; ++i)\n    {\n        float t = static_cast<float>(i) / (NumPoints - 1);\n\n        FVector Point = FMath::Lerp(StartPoint, EndPoint, t);\n\n        float ParabolicHeight = FMath::Square(t - 0.5f) * HeightOffset4 - HeightOffset;\n\n        Point.Z -= ParabolicHeight;\n\n        NewTrajectoryPoints.Add(Point);\n    }\n\n    NewTrajectoryPoints.Add(EndPoint);\n    TrajectoryPoints = MoveTemp(NewTrajectoryPoints);\n}\n\n// Spawn the projectile and set the trajectory points.\n\nvoid UPlayerThrowComponent::SpawnAndFollowProjectile(const TArray<FVector>& _TrajectoryPoints)\n{\n    if (ProjectileClass == nullptr && GEngine)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"Missing projectile to spawn\"));\n        return;\n    }\n    if (GetWorld())\n    {\n        AAProjectile* AProjectile = GetWorld()->SpawnActor<AAProjectile>(ProjectileClass, TrajectoryPoints[1], FRotator::ZeroRotator);\n        AProjectile->SetTrajectoryPoints(_TrajectoryPoints);\n\n        if (UnitToSpawn != nullptr)\n        {\n            AProjectile->ToSpawnClass = UnitToSpawn;\n        }\n        else if(GEngine)\n        {\n            GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"Missing troop to spawn in the ThrowComponent\"));\n        }\n    }\n}\n",
    "projectile": "// Spawn the projectile and set the trajectory points.\n\nAAProjectile::AAProjectile()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tProjectileMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"ProjectileMesh\"));\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Engine/BasicShapes/Sphere\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tProjectileMesh->SetStaticMesh(MeshAsset.Object);\n\t\tProjectileMesh->SetRelativeScale3D(FVector(0.1f, 0.1f, 0.1f));\n\t\tProjectileMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t}\n\n\tCurrentTrajectoryPointIndex = 0;\n}\n\nvoid AAProjectile::SetTrajectoryPoints(TArray<FVector> NewTrajectoryPoints)\n{\n\tTrajectoryPoints = NewTrajectoryPoints;\n\tCurrentTrajectoryPointIndex = 0;\n}\n\nvoid AAProjectile::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TrajectoryPoints.Num() > 0)\n\t{\n\t\tFVector CurrentLocation = GetActorLocation();\n\t\tFVector TargetLocation = TrajectoryPoints[CurrentTrajectoryPointIndex];\n\n\t\tSetActorLocation(FMath::VInterpConstantTo(CurrentLocation, TargetLocation, DeltaTime, Speed));\n\n\t\tif (FVector::Distance(CurrentLocation, TargetLocation) < 0.1f)\n\t\t\tCurrentTrajectoryPointIndex++;\n\n\t\tif (CurrentTrajectoryPointIndex >= TrajectoryPoints.Num() - 1)\n\t\t{\n\t\t\tif (ToSpawnClass != nullptr)\n\t\t\t{\n\t\t\t\tACharacter* SpawnedActor = nullptr;\n\n\t\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\t\tSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n\n\t\t\t\tSpawnedActor = GetWorld()->SpawnActor<ACharacter>(ToSpawnClass, GetActorLocation(), GetActorRotation(), SpawnParams);\n\n\t\t\t\tif (SpawnedActor != nullptr)\n\t\t\t\t{\n\t\t\t\t\tGEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Green, TEXT(\"Spawned troop\"));\n\t\t\t\t\tSpawnedActor->SpawnDefaultController();\n\t\t\t\t}\n\t\t\t\telse if (GEngine)\n\t\t\t\t\tGEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"Failed to spawn troop\"));\n\t\t\t}\n\t\t\telse if (GEngine)\n\t\t\t\tGEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"Missing troop to spawn\"));\n\n\t\t\tDestroy();\n\t\t}\n\t}\n}\n\nvoid AAProjectile::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n"
}
