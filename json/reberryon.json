{
    "parabolic": "// Main throw function.\n\nvoid UPlayerThrowComponent::Throw()\n{\n    UUUnitHandler* UnitHandlerRef = Cast<UUUnitHandler>(GetOwner()->GetComponentByClass(UUUnitHandler::StaticClass()));\n\n    if (UnitHandlerRef == nullptr)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"UnitHandler is null\"));\n        return;\n    }\n\n    if (UnitHandlerRef->CurrentUnits <= 0)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"No units to throw\"));\n        return;\n    }\n\n    if (!bReleaseToShoot && bIsAiming && bRayHit)\n    {\n        SpawnAndFollowProjectile(TrajectoryPoints);\n        UnitHandlerRef->CurrentUnits--;\n    }\n}\n\n// Calls Debugs and Raycast.\n\nvoid UPlayerThrowComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);\n    if (bIsAiming)\n    {\n        Ray();\n\n        if (TrajectoryPoints.Num() > 0)\n        {\n            UpdateTrajectoryMaterials();\n            UpdateTrajectoryMeshes(TrajectoryPoints);\n        }\n    }\n}\n\n// Raycast from the player to the mouse position, also calculate player and camera distance\n\nvoid UPlayerThrowComponent::Ray()\n{\n    FVector2D MousePosition;\n    APlayerController* PlayerControllerRef = UGameplayStatics::GetPlayerController(GetWorld(), 0);\n\n    if (!PlayerControllerRef || !PlayerControllerRef->GetMousePosition(MousePosition.X, MousePosition.Y))\n    {\n        return;\n    }\n\n    FVector WorldLocation, WorldDirection;\n    if (!UGameplayStatics::DeprojectScreenToWorld(PlayerControllerRef, MousePosition, WorldLocation, WorldDirection))\n    {\n        return;\n    }\n\n    APlayerCameraManager* PlayerCamera = GetWorld()->GetFirstPlayerController()->PlayerCameraManager;\n    if (!PlayerCamera)\n    {\n        return;\n    }\n\n    FVector CameraLocation = PlayerCamera->GetCameraLocation();\n    float PlayerAndCameraDistance = FVector::Distance(PlayerControllerRef->GetPawn()->GetActorLocation(), CameraLocation);\n\n    FVector Start = WorldLocation;\n    FVector End = Start + WorldDirection * (ThrowRange + PlayerAndCameraDistance);\n\n    DrawDebugSphere(GetWorld(), GetOwner()->GetActorLocation(), ThrowRange, 8, FColor::Red, false, -1.f, 0);\n\n    FHitResult Hit;\n    TArray<AActor*> ActorsToIgnore = { GetOwner() };\n    TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes = {\n        UEngineTypes::ConvertToObjectType(ECC_WorldStatic),\n        UEngineTypes::ConvertToObjectType(ECC_Pawn)\n    };\n\n    bool ActorHit = UKismetSystemLibrary::LineTraceSingleForObjects(GetWorld(), Start, End, ObjectTypes, false, ActorsToIgnore, EDrawDebugTrace::None, Hit, true, FLinearColor::Red, FLinearColor::Green, 0.05f);\n\n    bRayHit = ActorHit;\n\n    if (ActorHit && Hit.GetActor())\n    {\n        float ThrowHeight = FVector::Distance(PlayerControllerRef->GetPawn()->GetActorLocation(), Hit.ImpactPoint) / 2 * ThrowMultiplier;\n        DrawThrowCurve(PlayerControllerRef->GetPawn()->GetActorLocation(), Hit.ImpactPoint, ThrowHeight, SmoothnessOfCurve, FColor::Green);\n    }\n    else\n    {\n        FVector MousePosAtEdge = Start + WorldDirection * ThrowRange;\n        float ThrowHeight = FVector::Distance(PlayerControllerRef->GetPawn()->GetActorLocation(), MousePosAtEdge) / 2 * ThrowMultiplier;\n        DrawThrowCurve(PlayerControllerRef->GetPawn()->GetActorLocation(), MousePosAtEdge, ThrowHeight, SmoothnessOfCurve, FColor::Red);\n    }\n}\n\n// Calculate the projectile trajectory.\n\nvoid UPlayerThrowComponent::DrawThrowCurve(const FVector& StartPoint, const FVector& EndPoint, float HeightOffset, int32 NumPoints, FColor Color)\n{\n    if (NumPoints < 2) return;\n\n    TArray<FVector> NewTrajectoryPoints;\n    NewTrajectoryPoints.Reserve(NumPoints);\n\n    NewTrajectoryPoints.Add(StartPoint);\n\n    float HeightOffset4 = 4.0f * HeightOffset;\n\n    for (int32 i = 1; i < NumPoints - 1; ++i)\n    {\n        float t = static_cast<float>(i) / (NumPoints - 1);\n\n        FVector Point = FMath::Lerp(StartPoint, EndPoint, t);\n\n        float ParabolicHeight = FMath::Square(t - 0.5f) * HeightOffset4 - HeightOffset;\n\n        Point.Z -= ParabolicHeight;\n\n        NewTrajectoryPoints.Add(Point);\n    }\n\n    NewTrajectoryPoints.Add(EndPoint);\n    TrajectoryPoints = MoveTemp(NewTrajectoryPoints);\n}\n\n// Spawn the projectile and set the trajectory points.\n\nvoid UPlayerThrowComponent::SpawnAndFollowProjectile(const TArray<FVector>& _TrajectoryPoints)\n{\n    if (ProjectileClass == nullptr && GEngine)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"Missing projectile to spawn\"));\n        return;\n    }\n    if (GetWorld())\n    {\n        AAProjectile* AProjectile = GetWorld()->SpawnActor<AAProjectile>(ProjectileClass, TrajectoryPoints[1], FRotator::ZeroRotator);\n        AProjectile->SetTrajectoryPoints(_TrajectoryPoints);\n\n        if (UnitToSpawn != nullptr)\n        {\n            AProjectile->ToSpawnClass = UnitToSpawn;\n        }\n        else if(GEngine)\n        {\n            GEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"Missing troop to spawn in the ThrowComponent\"));\n        }\n    }\n}\n",
    "projectile": "// Spawn the projectile and set the trajectory points.\n\nAAProjectile::AAProjectile()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\tProjectileMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"ProjectileMesh\"));\n\n\tstatic ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset(TEXT(\"/Engine/BasicShapes/Sphere\"));\n\tif (MeshAsset.Succeeded())\n\t{\n\t\tProjectileMesh->SetStaticMesh(MeshAsset.Object);\n\t\tProjectileMesh->SetRelativeScale3D(FVector(0.1f, 0.1f, 0.1f));\n\t\tProjectileMesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\t}\n\n\tCurrentTrajectoryPointIndex = 0;\n}\n\nvoid AAProjectile::SetTrajectoryPoints(TArray<FVector> NewTrajectoryPoints)\n{\n\tTrajectoryPoints = NewTrajectoryPoints;\n\tCurrentTrajectoryPointIndex = 0;\n}\n\nvoid AAProjectile::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (TrajectoryPoints.Num() > 0)\n\t{\n\t\tFVector CurrentLocation = GetActorLocation();\n\t\tFVector TargetLocation = TrajectoryPoints[CurrentTrajectoryPointIndex];\n\n\t\tSetActorLocation(FMath::VInterpConstantTo(CurrentLocation, TargetLocation, DeltaTime, Speed));\n\n\t\tif (FVector::Distance(CurrentLocation, TargetLocation) < 0.1f)\n\t\t\tCurrentTrajectoryPointIndex++;\n\n\t\tif (CurrentTrajectoryPointIndex >= TrajectoryPoints.Num() - 1)\n\t\t{\n\t\t\tif (ToSpawnClass != nullptr)\n\t\t\t{\n\t\t\t\tACharacter* SpawnedActor = nullptr;\n\n\t\t\t\tFActorSpawnParameters SpawnParams;\n\t\t\t\tSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n\n\t\t\t\tSpawnedActor = GetWorld()->SpawnActor<ACharacter>(ToSpawnClass, GetActorLocation(), GetActorRotation(), SpawnParams);\n\n\t\t\t\tif (SpawnedActor != nullptr)\n\t\t\t\t{\n\t\t\t\t\tGEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Green, TEXT(\"Spawned troop\"));\n\t\t\t\t\tSpawnedActor->SpawnDefaultController();\n\t\t\t\t}\n\t\t\t\telse if (GEngine)\n\t\t\t\t\tGEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"Failed to spawn troop\"));\n\t\t\t}\n\t\t\telse if (GEngine)\n\t\t\t\tGEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"Missing troop to spawn\"));\n\n\t\t\tDestroy();\n\t\t}\n\t}\n}\n\nvoid AAProjectile::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n",
    "curve": "//Update the trajectory materials\n\nvoid UPlayerThrowComponent::UpdateTrajectoryMaterials()\n{\n    if(GEngine && !CanShootMaterial && !CannotShootMaterial)\n\t{\n\t\tGEngine->AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, TEXT(\"Missing CanShootMaterial in the ThrowComponent\"));\n\t\treturn;\n\t}\n\n    UMaterial* SelectedMaterial = bRayHit ? CanShootMaterial : CannotShootMaterial;\n\n    for (UStaticMeshComponent* MeshComponent : TrajectoryMeshes)\n    {\n        if (MeshComponent)\n        {\n            MeshComponent->SetMaterial(0, SelectedMaterial);\n        }\n    }\n}\n\n//Update the trajectory meshes\n\nvoid UPlayerThrowComponent::UpdateTrajectoryMeshes(const TArray& Points)\n{\n    float SegmentSize = 1.0f / FMath::Max(1, Points.Num());\n\n    for (int32 i = 0; i < Points.Num(); ++i)\n    {\n        float NormalizedIndex = (i + 1) * SegmentSize;\n        float ScaleValue = 0.1f;\n\n        if (SizeCurve)\n        {\n            ScaleValue = SizeCurve->GetFloatValue(NormalizedIndex);\n        }\n\n        if (i < TrajectoryMeshes.Num())\n        {\n            TrajectoryMeshes[i]->SetWorldLocation(Points[i]);\n            TrajectoryMeshes[i]->SetWorldScale3D(FVector(ScaleValue));\n            TrajectoryMeshes[i]->SetVisibility(true);\n        }\n        else\n        {\n            UStaticMeshComponent* MeshComponent = NewObject<UStaticMeshComponent>(this);\n            MeshComponent->RegisterComponent();\n            MeshComponent->AttachToComponent(GetOwner()->GetRootComponent(), FAttachmentTransformRules::KeepRelativeTransform);\n            MeshComponent->SetStaticMesh(LineMesh);\n            MeshComponent->SetWorldLocation(Points[i]);\n            MeshComponent->SetWorldScale3D(FVector(ScaleValue));\n            MeshComponent->SetVisibility(true);\n\n            TrajectoryMeshes.Add(MeshComponent);\n        }\n    }\n\n    for (int32 i = Points.Num(); i < TrajectoryMeshes.Num(); ++i)\n    {\n        TrajectoryMeshes[i]->SetVisibility(false);\n    }\n}\n\n//Clear the trajectory meshes.\n\nvoid UPlayerThrowComponent::ClearTrajectoryMeshes()\n{\n    for (UStaticMeshComponent* MeshComponent : TrajectoryMeshes)\n    {\n        MeshComponent->DestroyComponent();\n    }\n    TrajectoryMeshes.Empty();\n}",
    "key": "//Retrieves all the doors in the scene.\n\nvoid AAKey::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (DoorsInScene.Num() == 0) \n\t{\n\t\tTArray<AActor*> TempActors;\n\t\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AAGate::StaticClass(), TempActors);\n\n\t\tfor(AActor* Actor : TempActors)\n\t\t{\n\t\t\tAAGate* Gate = Cast<AAGate>(Actor);\n\t\t\tif(Gate)\n\t\t\t{\n\t\t\t\tDoorsInScene.Add(Gate);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (DoorsInScene.Num() == 0)\n\t\tGEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT(\"No Door Found In Scene\"));\n}\n\n//Simple state machine.\n\nvoid AAKey::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tswitch (EState)\n\t{\n\t\tcase KeyState::Idle:\n\t\t\t\tPickUp();\n\t\t\tbreak;\n\n\t\tcase KeyState::FollowingPlayer:\n\t\t\t\tFollowPlayer();\n\t\t\tbreak;\n\n\t\tcase KeyState::OpeningDoor:\n\t\t\t\tOpenDoor();\n\t\t\tbreak;\n\t}\n\n\tif (GEngine) \n\t{\n\t\tDrawDebugSphere(GetWorld(), GetActorLocation(), DetectionRange, 20, FColor::Red, false, 0.f, 0, .5f);\n\t\tDrawDebugString(GetWorld(), GetActorLocation(), UEnum::GetValueAsString(EState), nullptr, FColor::Red, 0.1f * DeltaTime, true);\n\t}\n}\n\n//Starts following player.\n\nvoid AAKey::PickUp()\n{\n\tFVector PlayerLocation = GetWorld()->GetFirstPlayerController()->GetPawn()->GetActorLocation();\n\tFVector KeyLocation = GetActorLocation();\n\n\tfloat Distance = FVector::Dist(PlayerLocation, KeyLocation);\n\n\tif (Distance < DetectionRange)\n\t{\n\t\tEState = KeyState::FollowingPlayer;\n\t}\n}\n\n//Starts following the player until the Key is close to a door.\n\nvoid AAKey::FollowPlayer()\n{\n\tFVector KeyLocation = GetActorLocation();\n\tFVector PlayerLocation = GetWorld()->GetFirstPlayerController()->GetPawn()->GetActorLocation();\n\n\tMoveAndRotateTowards(KeyLocation, PlayerLocation, Speed, MinDistance);\n\n\tif (DoorsInScene.Num() > 0)\n\t{\n\t\tfor (int i = 0; i < DoorsInScene.Num(); i++) \n\t\t{\n\t\t\tFVector DoorLocation = DoorsInScene[i]->GetActorLocation();\n\n\t\t\tif (FVector::Dist(KeyLocation, DoorLocation) < DetectionRange)\n\t\t\t{\n\t\t\t\tDoorToOpen = DoorsInScene[i];\n\t\t\t\tEState = KeyState::OpeningDoor;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Opens the gate and plays the animations.\n\nvoid AAKey::OpenDoor()\n{\n\tif (DoorToOpen == nullptr)\n\t\treturn;\n\n\tFVector CurrentLocation = GetActorLocation();\n\tFVector DoorLocation = DoorToOpen->GetActorLocation();\n\tFVector LockLocation = DoorLocation + DoorToOpen->GetActorRightVector() * 100;\n\tfloat DeltaTime = GetWorld()->GetDeltaSeconds();\n\n\tFVector NewLocation = FMath::Lerp(CurrentLocation, LockLocation, Speed * DeltaTime);\n\tFVector Direction = DoorLocation - CurrentLocation;\n\tDirection.Normalize();\n\n\tif (!CurrentLocation.Equals(LockLocation, 10))\n\t\tSetActorLocation(NewLocation);\n\n\tSetActorRotation(Direction.Rotation());\n\n\tif (FVector::Dist(CurrentLocation, LockLocation) < 20)\n\t{\n\t\tDoorsInScene.Remove(DoorToOpen);\n\t\tDoorToOpen->OpenGate();\n\t\tAnimateKey();\n\t}\n}\n\n//A function to move and rotate objects used in all of the behaviours.\n\nvoid AAKey::MoveAndRotateTowards(FVector CurrentLocation, FVector TargetLocation, float NewSpeed, float NewMinDistance)\n{\n\tfloat DeltaTime = GetWorld()->GetDeltaSeconds();\n\n\tFVector Direction = TargetLocation - CurrentLocation;\n\tDirection.Normalize();\n\n\tFVector NewLocation = FMath::Lerp(CurrentLocation, TargetLocation, NewSpeed * DeltaTime);\n\n\tif (FVector::Dist(CurrentLocation, TargetLocation) > NewMinDistance)\n\t{\n\t\tSetActorLocation(NewLocation);\n\t}\n\n\tSetActorRotation(Direction.Rotation());\n}"
}
